<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.theory.core.theoryRoot org.eventb.core.configuration="org.eventb.theory.core.thy">
    <org.eventb.theory.core.typeParameter name="'" org.eventb.core.identifier="Belief_predicate_symbols"/>
    <org.eventb.theory.core.typeParameter name="(" org.eventb.core.identifier="Event_Action_predicate_symbols"/>
    <org.eventb.theory.core.typeParameter name=")" org.eventb.core.identifier="Terms"/>
    <org.eventb.theory.core.newOperatorDefinition name="+" org.eventb.core.label="isRevelant_plans" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="/" org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.datatypeDefinition name="element:" org.eventb.core.comment="The two data type follow the grammar define in the fig 4 a yours SCP paper entitle &quot;Modelling and verifying BDI agents with bigraphs&quot;" org.eventb.core.identifier="UserP">
        <org.eventb.theory.core.typeArgument name="'" org.eventb.theory.core.givenType="Belief_predicate_symbols"/>
        <org.eventb.theory.core.typeArgument name="(" org.eventb.theory.core.givenType="Event_Action_predicate_symbols"/>
        <org.eventb.theory.core.typeArgument name=")" org.eventb.theory.core.givenType="Terms"/>
        <org.eventb.theory.core.datatypeConstructor name="element1" org.eventb.core.identifier="BasicP_user">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="basic_program_user" org.eventb.theory.core.type="Event_Action_predicate_symbols × Terms"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element2" org.eventb.core.identifier="Sequence_user">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="head_user" org.eventb.theory.core.type="UserP(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="tail_user" org.eventb.theory.core.type="UserP(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element3" org.eventb.core.identifier="Concurrency_user">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="left_user" org.eventb.theory.core.type="UserP(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="right_user" org.eventb.theory.core.type="UserP(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element4" org.eventb.core.identifier="Declarative_goal_user">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="success_condition_user" org.eventb.theory.core.type="ℙ(Belief_predicate_symbols × Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.comment="strickly, it should be Event_predicate_symbols " org.eventb.core.identifier="event_user" org.eventb.theory.core.type="Event_Action_predicate_symbols × Terms"/>
            <org.eventb.theory.core.constructorArgument name=")" org.eventb.core.identifier="failure_condition_user" org.eventb.theory.core.type="ℙ(Belief_predicate_symbols × Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
    </org.eventb.theory.core.datatypeDefinition>
    <org.eventb.theory.core.datatypeDefinition name="*" org.eventb.core.identifier="P">
        <org.eventb.theory.core.typeArgument name="'" org.eventb.theory.core.givenType="Belief_predicate_symbols"/>
        <org.eventb.theory.core.typeArgument name="(" org.eventb.theory.core.givenType="Event_Action_predicate_symbols"/>
        <org.eventb.theory.core.typeArgument name=")" org.eventb.theory.core.givenType="Terms"/>
        <org.eventb.theory.core.datatypeConstructor name="/" org.eventb.core.identifier="Nil"/>
        <org.eventb.theory.core.datatypeConstructor name="+" org.eventb.core.identifier="BasicP_intention">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="basic_program_intention" org.eventb.theory.core.type="Event_Action_predicate_symbols × Terms"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="-" org.eventb.core.identifier="Sequence_intention">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="head_intention" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="tail_intention" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="." org.eventb.core.identifier="Concurrency_intention">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="left_intention" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="right_intention" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="*" org.eventb.core.identifier="Declarative_goal_intention">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="success_condition" org.eventb.theory.core.type="ℙ(Belief_predicate_symbols × Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="procedural_program" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name=")" org.eventb.core.identifier="failure_condition" org.eventb.theory.core.type="ℙ(Belief_predicate_symbols × Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element1" org.eventb.core.comment="P1 |&gt; P2" org.eventb.core.identifier="Try_current_with_backups">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="current_intention" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="backup_plans" org.eventb.theory.core.type="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element2" org.eventb.core.identifier="Relevant_plans">
            <org.eventb.theory.core.constructorArgument name="'" org.eventb.core.identifier="triggering_event" org.eventb.theory.core.type="Event_Action_predicate_symbols × Terms"/>
            <org.eventb.theory.core.constructorArgument name="(" org.eventb.core.identifier="set_of_guarded_plan_bodies" org.eventb.theory.core.type="ℙ(ℙ(Belief_predicate_symbols × Terms) × UserP(Belief_predicate_symbols , Event_Action_predicate_symbols, Terms))"/>
        </org.eventb.theory.core.datatypeConstructor>
        <org.eventb.theory.core.datatypeConstructor name="element3" org.eventb.core.comment="for declarative goal when the failure conditions holds, it progresses to False.  I should add this to the new Fig for &quot;Grammer of plans and plan-bodies&quot;" org.eventb.core.identifier="False"/>
    </org.eventb.theory.core.datatypeDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element;" org.eventb.core.label="type_UserP_to_P" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="UserP(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) " org.eventb.core.identifier="userP"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="userP">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Declarative_goal_user(s, evt, failure)" org.eventb.theory.core.formula="Declarative_goal_intention(s, BasicP_intention(evt), failure)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.comment="I add the id application to Id to add the missing information for the typing " org.eventb.core.expression="BasicP_user(basic_program)" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(BasicP_intention(basic_program))"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Sequence_user(head,tail)" org.eventb.theory.core.formula="Sequence_intention(type_UserP_to_P(head)  , type_UserP_to_P(tail)  )"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Concurrency_user(left,right)" org.eventb.theory.core.formula="Concurrency_intention(type_UserP_to_P(left)   , type_UserP_to_P(right)   ) "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element=" org.eventb.core.comment="similar to the stack, get first return the set of atomic elementon the top of the plan " org.eventb.core.label="next_programs_to_progress" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) " org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="(ℙ(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) )◁id)({Nil})"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula=" (ℙ(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) )◁ id)({BasicP_intention(basic_program)})"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.comment="corresponds to the rule of ;" org.eventb.core.expression="Sequence_intention(head, tail)" org.eventb.theory.core.formula="next_programs_to_progress(head)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.comment="corresponds to the rule of ||1 and ||2" org.eventb.core.expression="Concurrency_intention(left, right)" org.eventb.theory.core.formula="next_programs_to_progress(left)∪next_programs_to_progress(right)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.comment="in declarative goal setting, we first lcoate the declarative goal, &#10;and then re-apply next_programs_to_progress&#10; to locate which program to process first inside the declarative goal" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="{Declarative_goal_intention(s,procedual,f)}"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.comment="corresponds to the rule rhd_;" org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="next_programs_to_progress(current)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies) " org.eventb.theory.core.formula="{Relevant_plans(event, guarded_plan_bodies) }"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="(ℙ(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) )◁id)({False})"/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element&gt;" org.eventb.core.comment="update a plan, and preserve the concurent et sequence order" org.eventb.core.label="update_intention" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.operatorArgument name="(" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="current_program"/>
        <org.eventb.theory.core.operatorArgument name=")" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="new_program"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="*" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="{current ↦ new ∣ &#10;&#9;  current = BasicP_intention(basic_program)&#10;      ∧ new = new_program&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.comment="corresponds to the rule ;" org.eventb.core.expression="Sequence_intention(tail, head)" org.eventb.theory.core.formula="Sequence_intention(update_intention(tail,current_program,new_program),head)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.comment="what about &#10;current ∈  next_programs_to_progress(left) &#10;∧ current ∈ next_programs_to_progress(right) &#10;&#10;a bit pointless as act || act has same effect to act!&#10;the simutoneous actions with left arm and right arm&#10;can always be modelled as act_l || act_r for a robot" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="{current ↦ new ∣ &#10;       (current ∈ next_programs_to_progress(left)&#10;        ∧ current ∉ next_programs_to_progress(right)&#10;        ∧ new = Concurrency_intention(update_intention(left,current_program,new_program),right) &#10;       ) &#10;∨ &#10;       (current ∉ next_programs_to_progress(left) &#10;        ∧ current ∈ next_programs_to_progress(right) &#10;        ∧ new =Concurrency_intention(left,update_intention(right,current_program,new_program) ) &#10;        )&#10; }(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.comment="if we need to update the declarative goal structure, then first case applies&#10;if we need to update an element inside a declarative goal, then second case applies&#10;the argument of the &quot;current_program&quot; is important" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="{current ↦ new ∣ &#10;      (current = Declarative_goal_intention(s,procedual,f) &#10;      ∧ new = new_program&#10;      ) &#10;∨  &#10;      (current ≠ Declarative_goal_intention(s,procedual,f) &#10;      ∧ new = Declarative_goal_intention(s,update_intention(procedual,current_program,new_program),f)&#10;     )&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="Try_current_with_backups(update_intention(current,current_program,new_program), backups) "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.comment="update the current relevant plan sets to one single selected applicable plan" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies) " org.eventb.theory.core.formula="{current ↦ new ∣ &#10;&#9;  current = Relevant_plans(event, guarded_plan_bodies) &#10;      ∧ new = new_program&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.comment="no change as i do not need the case of nil, but the Rodin forces me to include all cases&#10;Nil removal process itelf is a different operator" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(Nil)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="/" org.eventb.core.comment="no change as i do not need the case of nil, but the Rodin forces me to include all cases&#10;To deal with False for declarative goal requires the failure recovery" org.eventb.core.expression="False" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(False)"/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element?" org.eventb.core.label="isBasicP_intention" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element@" org.eventb.core.label="isSequence_intention" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementA" org.eventb.core.label="isConcurrency_intention" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementB" org.eventb.core.label="isDeclarative_goal_intention" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementC" org.eventb.core.label="isTry_current_with_backups" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementD" org.eventb.core.label="isNil" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊤ "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊥ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementE" org.eventb.core.comment="the operator to deal with the update of intention when there is nil, including sequence, failure recovery,  concurrency structure&#10;and inside the procedual intention of a declarative goal. " org.eventb.core.label="NilRemove" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.comment="Nil on itself will not be removed (as a successfully executed intention will become nil)&#10;Nil remove is to handle the removal of nil in the sequence, concurrency, and failure recovery structure" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(Nil) "/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.comment="we need to go through each case &#10;because of the restriction of recursive definition in Rodin" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(BasicP_intention(basic_program))"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="{new_intention, h, t  · &#10;       (isNil(h) ∧ new_intention= t) &#10;       ∨ &#10;       ( ¬isNil(h) ∧ new_intention=Sequence_intention(NilRemove(h),t) )&#10;       ∣ (h↦t)↦new_intention&#10;}(head↦tail)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.comment="this recursive definition of NilRemove is to &#10;addres the situation from&#10;( (act || nil) || nil) || nil&#10;when act is exected to be nil&#10;we have &#10;( (nil || nil) || nil) || nil)&#10;it requires some good explanation in the paper" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="{new_intention, l1, r1, l2, r2 · &#10;                l2=NilRemove(l1) &#10;           ∧ r2=NilRemove(r1) &#10;           ∧ &#10;               ( &#10;                    ( isNil(l2) ∧ isNil(r2) ∧ new_intention= Nil ) &#10;                     ∨ &#10;                    (  (¬isNil(l2)  ∨ ¬ isNil(r2)) ∧ new_intention = Concurrency_intention(l2, r2) ) &#10;               ) &#10;             ∣ (l1↦r1)↦new_intention&#10;}(left ↦ right)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="Declarative_goal_intention(s,NilRemove(procedual),f)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="{new_intention,curr, back · &#10;     (isNil(curr) ∧ new_intention = Nil)&#10;     ∨ &#10;     (¬ isNil(curr) ∧ new_intention= Try_current_with_backups(NilRemove(curr),back)) &#10;     ∣ (curr ↦ back) ↦ new_intention&#10;}(current ↦ backups)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.comment="nothing will need to change" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="Relevant_plans(event, guarded_plan_bodies)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(False) "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementF" org.eventb.core.label="isFalse" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="false" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression=" P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.expression="Declarative_goal_intention(s,procedual,f)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="⊥"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="⊤ "/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="element3" org.eventb.core.comment="when we do failure recovery, we really just need to focuse on P1 |&gt; P2, so we need to recursively identify Rhd structure" org.eventb.core.label="failure_recovery" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="(" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.comment="nothing changes" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)◁id)(Nil)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula=" (P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) ◁ id)(BasicP_intention(basic_program) )"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.comment="continue to find Try_current_with_backups structure" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="{current ↦ new_search ∣ &#10;      current ∈ next_programs_to_progress(head)&#10;      ∧ new_search = Sequence_intention(failure_recovery(head, current_program, backup_relevant_plans), tail)&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="{current ↦ new_search ∣ &#10;       (current ∈ next_programs_to_progress(left)&#10;        ∧ current ∉ next_programs_to_progress(right)&#10;        ∧ new_search = Concurrency_intention(failure_recovery(left, current_program, backup_relevant_plans), right) &#10;       ) &#10;∨ &#10;       (current ∉ next_programs_to_progress(left) &#10;        ∧ current ∈ next_programs_to_progress(right) &#10;        ∧ new_search =Concurrency_intention(left,failure_recovery(right,current_program,backup_relevant_plans) ) &#10;        )&#10; }(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.comment="this is for the standard failure recovery,&#10;not the failure recovery to re-instantiate the event in a declarative goal, &#10;i.e. persistent execution of  declarative goal&#10;It allows to get into the procedual in the declarative goal" org.eventb.core.expression="Declarative_goal_intention(s,procedural,f)" org.eventb.theory.core.formula="{current ↦ new_search ∣ &#10;      current ∈ next_programs_to_progress(procedural) &#10;      ∧ new_search = Declarative_goal_intention(s,failure_recovery(procedural, current_program, backup_relevant_plans), f) &#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.comment="this is where the failure recovery occurs&#10;&#10;some note:&#10;1. current_program ∈ next_programs_to_progress(curr)&#10;seems to be a bit flawed, in particular,&#10;we know next_programs_to_progress stops &#10;when it comes to declarative goal&#10;But the second case still handles this edge case of declarative goal &#10;by relying on ¬ back = backup_relevant_plans&#10;&#10;the reason being is that &#10;if the failure recovery needs to happen in the procedual part in a declarative goal&#10;the triggering event of a plan that contains such a declarative goal&#10;has to be difference from the procedual event intention in this declarative goal&#10;i.e. NO e: context &lt;-- goal(s, e, f), i.e. not nested declarative goal&#10;&#10;On the top of that&#10;to transform Try_current_with_backups(current, backup)&#10;to back, we need to be absolutely sure by checking&#10; back = backup_relevant_plans &#10; ∧ current_program ∈ next_programs_to_progress(curr)&#10;&#10;To continue to search, as long as one does not meet, &#10;we carry on. &#10;&#10;Plus we also double check  if &#10;      current ∈ next_programs_to_progress(procedural) &#10;in the declarative goal when we reach there&#10;" org.eventb.core.expression="Try_current_with_backups(current, backup)" org.eventb.theory.core.formula="{ (curr↦back) ↦ new_intention_or_search  ∣ &#10;         (&#10;                ( back = backup_relevant_plans &#10;                ∧ current_program ∈ next_programs_to_progress(curr) &#10;                ∧ new_intention_or_search = back&#10;                 ) &#10;           ∨ &#10;                (  ¬  (back = backup_relevant_plans ∧ current_program ∈ next_programs_to_progress(curr) )  &#10;                ∧ new_intention_or_search = Try_current_with_backups(failure_recovery(current, current_program, backup_relevant_plans) ,back)&#10;                 )&#10;            ) &#10;} (current↦backup)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.comment="nothing changes" org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="Relevant_plans(event, guarded_plan_bodies)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="(P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms) ◁id)(False)"/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
        <org.eventb.theory.core.operatorArgument name=")" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="current_program"/>
        <org.eventb.theory.core.operatorArgument name="*" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="backup_relevant_plans"/>
    </org.eventb.theory.core.newOperatorDefinition>
    <org.eventb.theory.core.newOperatorDefinition name="elementG" org.eventb.core.label="get_backups_for_current_program" org.eventb.theory.core.associative="false" org.eventb.theory.core.commutative="false" org.eventb.theory.core.formulaType="true" org.eventb.theory.core.notationType="PREFIX">
        <org.eventb.theory.core.operatorArgument name="'" org.eventb.core.comment="current intention" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="intention"/>
        <org.eventb.theory.core.operatorArgument name="(" org.eventb.core.comment="the current program from next_programs_to_progress" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="current_program"/>
        <org.eventb.theory.core.operatorArgument name=")" org.eventb.core.comment="the returned backups for the current (must be initialised)" org.eventb.core.expression="P(Belief_predicate_symbols, Event_Action_predicate_symbols, Terms)" org.eventb.core.identifier="backup_relevant_plans"/>
        <org.eventb.theory.core.recursiveOperatorDefinition name="*" org.eventb.theory.core.inductiveArgument="intention">
            <org.eventb.theory.core.recursiveDefinitionCase name="'" org.eventb.core.comment="it means that i need to provide some default rhd return value " org.eventb.core.expression="BasicP_intention(basic_program)" org.eventb.theory.core.formula="backup_relevant_plans"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="(" org.eventb.core.comment="does it make any difference to have&#10;&#10;{current ↦ new_search ∣ &#10;       current ∈ next_programs_to_progress(head)&#10;       ∧ new_search = get_backups_for_current_program(head, current, backup_relevant_plans)&#10;}(current_program)" org.eventb.core.expression="Sequence_intention(head,tail)" org.eventb.theory.core.formula="{current ↦ new_search ∣ &#10;       current ∈ next_programs_to_progress(head)&#10;       ∧ new_search = get_backups_for_current_program(head, current_program, backup_relevant_plans)&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name=")" org.eventb.core.comment="not act || act assumed" org.eventb.core.expression="Concurrency_intention(left,right)" org.eventb.theory.core.formula="{current ↦ next_search ∣  &#10;         (current ∈ next_programs_to_progress(left) &#10;        ∧ current ∉ next_programs_to_progress(right) &#10;        ∧ next_search = get_backups_for_current_program(left, current_program, backup_relevant_plans)&#10;         )&#10;   ∨  &#10;         (current ∉ next_programs_to_progress(left) &#10;         ∧ current ∈ next_programs_to_progress(right) &#10;         ∧ next_search = get_backups_for_current_program(right, current_program, backup_relevant_plans)&#10;         )&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="*" org.eventb.core.comment="in declarative goal setting, we first lcoate the declarative goal, &#10;and then re-apply next_programs_to_progress&#10; to locate which program to process first inside the declarative goal" org.eventb.core.expression="Declarative_goal_intention(s,procedural,f)" org.eventb.theory.core.formula="{current ↦ new_search_or_return ∣ &#10;           (current = Declarative_goal_intention(s,procedural,f) &#10;           ∧ new_search_or_return = backup_relevant_plans&#10;            )&#10;     ∨ &#10;           (current ≠ Declarative_goal_intention(s,procedural,f) &#10;           ∧ current ∈ next_programs_to_progress(procedural)&#10;           ∧ new_search_or_return = get_backups_for_current_program(procedural, current_program, backup_relevant_plans)&#10;           )&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="+" org.eventb.core.comment="initial backup_relevant_plans &#10;to be backups&#10;to obtain the fianl required a set of relevant backup plans" org.eventb.core.expression="Try_current_with_backups(current, backups)" org.eventb.theory.core.formula="{curr ↦ new_search ∣ &#10;       curr ∈ next_programs_to_progress(current)&#10;       ∧ new_search = get_backups_for_current_program(current, current_program, backups)&#10;}(current_program)"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="," org.eventb.core.expression="Relevant_plans(event, guarded_plan_bodies)" org.eventb.theory.core.formula="backup_relevant_plans"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="-" org.eventb.core.expression="Nil" org.eventb.theory.core.formula="backup_relevant_plans"/>
            <org.eventb.theory.core.recursiveDefinitionCase name="." org.eventb.core.expression="False" org.eventb.theory.core.formula="backup_relevant_plans"/>
        </org.eventb.theory.core.recursiveOperatorDefinition>
    </org.eventb.theory.core.newOperatorDefinition>
</org.eventb.theory.core.theoryRoot>
